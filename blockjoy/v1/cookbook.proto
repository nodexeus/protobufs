// UNSTABLE
// It is likely that these services will be modified / merged with other
// services.

syntax = "proto3";

package blockjoy.v1;

// ----------------------------- Cookbook Service -----------------------------

// Babel cookbook service.
service CookbookService {
  // Retrieve plugin for specific version and state.
  rpc RetrievePlugin(CookbookServiceRetrievePluginRequest) returns
    (CookbookServiceRetrievePluginResponse);
  // Retrieve image for specific version and state.
  rpc RetrieveImage(CookbookServiceRetrieveImageRequest) returns
    (CookbookServiceRetrieveImageResponse);
  // Retrieve kernel file for specific version and state.
  rpc RetrieveKernel(CookbookServiceRetrieveKernelRequest) returns
    (CookbookServiceRetrieveKernelResponse);
  // Retrieve hardware requirements for given identifier.
  rpc Requirements(CookbookServiceRequirementsRequest) returns
    (CookbookServiceRequirementsResponse);
  // Retrieve net configurations for given chain.
  rpc NetConfigurations(CookbookServiceNetConfigurationsRequest) returns
    (CookbookServiceNetConfigurationsResponse);
  // List all available babel versions.
  rpc ListBabelVersions(CookbookServiceListBabelVersionsRequest) returns
    (CookbookServiceListBabelVersionsResponse);
}

message CookbookServiceRetrievePluginRequest {
  ConfigIdentifier id = 1;
}

message CookbookServiceRetrievePluginResponse {
  Plugin plugin = 1;
}

message CookbookServiceRetrieveImageRequest {
  ConfigIdentifier id = 1;
}

message CookbookServiceRetrieveImageResponse {
  ArchiveLocation location = 1;
}

message CookbookServiceRetrieveKernelRequest {
  ConfigIdentifier id = 1;
}

message CookbookServiceRetrieveKernelResponse {
  ArchiveLocation location = 1;
}

message CookbookServiceRequirementsRequest {
  ConfigIdentifier id = 1;
}

message CookbookServiceRequirementsResponse {
  // The number of logical cores.
  uint64 cpu_count = 1;
  uint64 mem_size_bytes = 2;
  uint64 disk_size_bytes = 3;
}

message CookbookServiceNetConfigurationsRequest {
  ConfigIdentifier id = 1;
}

message CookbookServiceNetConfigurationsResponse {
  repeated NetworkConfiguration networks = 1;
}

message CookbookServiceListBabelVersionsRequest {
  string protocol = 1;
  string node_type = 2;
}

message CookbookServiceListBabelVersionsResponse {
  repeated ConfigIdentifier identifiers = 1;
}

// ------------------------------ Bundle Service ------------------------------

// Retrieve manage BVD bundles.
service BundleService {
  // Retrieve image for specific version and state.
  rpc Retrieve(BundleServiceRetrieveRequest) returns
    (BundleServiceRetrieveResponse);
  // List all available bundle versions.
  rpc ListBundleVersions(BundleServiceListBundleVersionsRequest) returns
    (BundleServiceListBundleVersionsResponse);
  // Delete bundle from storage.
  rpc Delete(BundleServiceDeleteRequest) returns
    (BundleServiceDeleteResponse);
}

message BundleServiceRetrieveRequest {
  BundleIdentifier id = 1;
}

message BundleServiceRetrieveResponse {
  ArchiveLocation location = 1;
}

message BundleServiceListBundleVersionsRequest {
}

message BundleServiceListBundleVersionsResponse {
  repeated BundleIdentifier identifiers = 1;
}

message BundleServiceDeleteRequest {
  BundleIdentifier id = 1;
}

message BundleServiceDeleteResponse {
}

// ----------------------------- Manifest Service -----------------------------

// Retrieve manage download manifests, mainly for blockchain data archives.
service ManifestService {
  // Retrieve image for specific version and state.
  rpc RetrieveDownloadManifest(ManifestServiceRetrieveDownloadManifestRequest)
      returns (ManifestServiceRetrieveDownloadManifestResponse);
}

message ManifestServiceRetrieveDownloadManifestRequest {
  ConfigIdentifier id = 1;
  string network = 2;
}

message ManifestServiceRetrieveDownloadManifestResponse {
  DownloadManifest manifest = 1;
}

// Type of compression used on chunk data.
enum Compression {
  COMPRESSION_UNSPECIFIED = 0;
}

// Checksum variant.
enum ChecksumType {
  CHECKSUM_TYPE_UNSPECIFIED = 0;
  CHECKSUM_TYPE_SHA1 = 1;
  CHECKSUM_TYPE_SHA256 = 2;
  CHECKSUM_TYPE_BLAKE3 = 3;
}

// Download manifest, describing a cloud to disk mapping.
// Sometimes it is necessary to put data into the cloud in a different form,
// because of cloud limitations or needed optimization.
message DownloadManifest {
  // Total size of uncompressed data
  uint64 total_size = 1;
  // Chunk compression type or none
  optional Compression compression = 2;
  // Full list of chunks
  repeated Chunk chunks = 3;
}

// Data is stored on the cloud in chunks. Each chunk may map into part
// of a single file or multiple files (i.e. original disk representation).
// Downloaded chunks, after decompression, shall be written into disk
// location(s) described by the destinations.
//
// Example of chunk-file mapping:
//```ascii flow
//                path: file1           path: file1          path: file1
//  compressed    pos: 0                pos: 1024            pos: 2048
//  ─────────┐    size: 1024            size: 1024           size: 1024
//           │  ┌────────────────────┬────────────────────┬───────────────────┐
//           │  │  decompressed      │                    │                   │
//           │  └────────────────────┴────────────────────┴───────────────────┘
//           │                ▲                 ▲                  ▲
//           ▼                │                 │                  │
//         ┌──┐               │                 │                  │
// chunk 1 │  │               │                 │                  │
//         │  ├───────────────┘                 │                  │
//         │  │                                 │                  │
//         └──┘                                 │                  │
//         ┌──┐                                 │                  │
// chunk 2 │  │                                 │                  │
//         │  ├─────────────────────────────────┘                  │
//         │  │                                                    │
//         └──┘                                                    │
//         ┌──┐                                                    │
// chunk 3 │  │    download and decompress                         │
//         │  ├────────────────────────────────────────────────────┘
//         │  │
//         └──┘
//         ┌──┐        ┌──────┐ path: file2
// chunk 4 │  ├───────►│      │ pos: 0
//         │  │        └──────┘ size: 256
//         ├──┤
//         │  │        ┌──────────────┐ path: file3
//         │  ├───────►│              │ pos: 0
//         │  │        └──────────────┘ size: 512
//         │  │
//         ├──┤        ┌────┐ path: file4
//         │  ├───────►│    │ pos: 0
//         └──┘        └────┘ size: 128
//```
message Chunk {
  // Persistent chunk key
  string key = 1;
  // Pre-signed download url (may be temporary)
  string url = 2;
  // Chunk data checksum type
  ChecksumType checksum_type = 3;
  // Chunk data checksum bytes
  bytes checksum = 4;
  // Chunk size in bytes
  uint64 size = 5;
  // Chunk to data files mapping
  repeated FileLocation destinations = 6;
}

// Structure describing where decompressed data shall be written to and how
// many bytes.
message FileLocation {
  // Relative file path
  string path = 1;
  // Position of data in the file
  uint64 position_bytes = 2;
  // Size of uncompressed data
  uint64 size_bytes = 3;
}

// ---------------------------- Common Definitions ----------------------------

// Message type used for identifying a specific plugin.
message ConfigIdentifier {
  // snake_cased name of the blockchain.
  string protocol = 1;
  // snake_cased name of the node type.
  string node_type = 2;
  // semantic version string of the node type version.
  string node_version = 3;
}

message BundleIdentifier {
  // semantic version string of the bundle version.
  string version = 1;
}

message Plugin {
  ConfigIdentifier identifier = 1;
  // Plugin script contents.
  bytes rhai_content = 2;
}

message ArchiveLocation {
  string url = 1;
}

enum NetType {
  NET_TYPE_UNSPECIFIED = 0;
  NET_TYPE_DEV = 1;
  NET_TYPE_TEST = 2;
  NET_TYPE_MAIN = 3;
}

message NetworkConfiguration {
  string name = 1;
  string url = 2;
  NetType net_type = 3;
  map<string, string> meta = 4;
}
